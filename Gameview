// --- View/Component Logic (Conceptual DOM/Framework structure) ---

const AppState = {
    showGame: false,
    showSecondSplash: false,
    showLevelSelection: false,
    selectedLevel: null, // 1-based index or null
    completedLevels: new Set(), // Store completed level indices
    gameLogic: null, // Instance of GameLogic for the current level
    isHowToPlayVisible: false
};

// Placeholder for state updates and re-rendering
function setState(newState, callback) {
    Object.assign(AppState, newState);
    renderApp(); // Global re-render function
    if (callback) callback();
}


// --- Simulated Views (Components) ---

// GameView Simulation (Uses Canvas/SVG for drawing)
function GameView(levelIndex) {
    if (!AppState.gameLogic || AppState.gameLogic.level.name !== LevelData[levelIndex - 1].name) {
        AppState.gameLogic = new GameLogic(levelIndex - 1);
        AppState.gameLogic.resetLevel();
    }
    
    const logic = AppState.gameLogic;
    
    // Renders the header, dot/line drawing area (Canvas/SVG), and reset button.
    // **DRAG GESTURE SIMULATION (Conceptual):**
    // The actual implementation would attach 'mousedown/touchstart', 'mousemove/touchmove',
    // and 'mouseup/touchend' listeners to the drawing area (e.g., a Canvas).
    
    /* Example interaction handler:
    
    const drawingArea = document.getElementById('game-canvas');
    drawingArea.onmousedown = (e) => {
        const loc = new Point(e.offsetX, e.offsetY);
        logic.handleDragStart(loc);
        setState({}); // Update view to show current line
    };

    drawingArea.onmousemove = (e) => {
        if (logic.currentLine) {
            const loc = new Point(e.offsetX, e.offsetY);
            logic.handleDragMove(loc);
            setState({}); // Update view to update current line
        }
    };

    drawingArea.onmouseup = (e) => {
        if (logic.currentLine) {
            const loc = new Point(e.offsetX, e.offsetY);
            const isCompleted = logic.handleDragEnd(loc);
            
            if (isCompleted) {
                AppState.completedLevels.add(levelIndex);
                setState({ showGame: false, gameLogic: null }); // Go back to level selection
            } else {
                setState({}); // Update view (current line cleared, valid line added or nothing)
            }
        }
    };
    */
    
    return `
        <div class="game-view-container">
            <button onclick="setState({ showGame: false })">Back</button>
            <h2>Level ${levelIndex}</h2>
            
            <div id="game-drawing-area" style="width: 300px; height: 300px; background: ${Color.white}; border: 1px solid black;">
                </div>
            
            <button onclick="logic.resetLevel(); setState({})">Reset Level</button>
        </div>
    `;
}

// LevelSelectionView Simulation
function LevelSelectionView() {
    const levelsHTML = Array.from({ length: totalLevels }, (_, i) => i + 1).map(level => {
        const isCompleted = AppState.completedLevels.has(level);
        const isLocked = level > AppState.completedLevels.size + 1;
        
        return `
            <button 
                onclick="${isLocked ? '' : `setState({ selectedLevel: ${level}, showGame: true })`}"
                style="background: ${Color.white}; color: ${isCompleted ? Color.yellow : (isLocked ? Color.gray : Color.blue)}; border: 1px solid ${isLocked ? Color.gray : Color.blue};"
                ${isLocked ? 'disabled' : ''}
            >
                ${level}
            </button>
        `;
    }).join('');

    return `
        <div class="level-selection-view">
            <button onclick="setState({ showLevelSelection: false, showSecondSplash: true })">Back</button>
            <h2>LEVELS</h2>
            <p>${AppState.completedLevels.size}/${totalLevels} Levels Completed</p>
            <div class="level-grid">${levelsHTML}</div>
        </div>
    `;
}

// SecondSplashView Simulation
function SecondSplashView() {
    // ... HTML structure for Second Splash Screen ...
    return `
        <div class="splash-screen">
            <h1>Pairflow</h1>
            <p>Match & Flow Your Way to Victory</p>
            <button onclick="setState({ showLevelSelection: true })">Play</button>
            <button onclick="setState({ isHowToPlayVisible: true })">How to Play</button>
            <p>Version 1.0</p>
            ${AppState.isHowToPlayVisible ? HowToPlayView() : ''}
        </div>
    `;
}

// FirstSplashView Simulation
function FirstSplashView() {
    // ... HTML structure for First Splash Screen ...
    return `
        <div class="splash-screen" style="background: ${Color.lightBlueBackground};">
            <h1>Pairflow</h1>
            <button onclick="setState({ showSecondSplash: true })">Tap to Start</button>
        </div>
    `;
}

// HowToPlayView Simulation (Conceptual Modal/Sheet)
function HowToPlayView() {
    return `
        <div class="modal">
            <div class="modal-content">
                <button onclick="setState({ isHowToPlayVisible: false })">Close</button>
                <h3>How to Play</h3>
                <p>Connect matching colored dots...</p>
                <button onclick="setState({ isHowToPlayVisible: false })">Start Playing</button>
            </div>
        </div>
    `;
}


// --- Main Entry Point (ContentView equivalent) ---

function ContentView() {
    if (AppState.showGame && AppState.selectedLevel !== null) {
        return GameView(AppState.selectedLevel);
    } else if (AppState.showLevelSelection) {
        return LevelSelectionView();
    } else if (AppState.showSecondSplash) {
        return SecondSplashView();
    } else {
        return FirstSplashView();
    }
}

// Global rendering function to update the DOM
function renderApp() {
    const appRoot = document.getElementById('app-root');
    if (appRoot) {
        appRoot.innerHTML = ContentView();
    }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', renderApp);
